Chapter 1. C++ Basics
=====================

1.1 Structure of a program
--------------------------

* Statement:
    - Smallest independent unit in the language.
    - Tells the compiler to perform a task.
    - Terminated by semicolon.
    - Examples: declaration, assignment and output.

* Expression:
    - Mathematical that evaluates to a value.
    - It may consist of values, variables, operators and functions.
    - Function: collection of statements that are evaluated sequentially.

* Library:
    - Collection of pre-compiled code packed for reuse in many different
      programs.

* Processor Directive:
    - Tell the compiler to perform a special task, i.e., add content of header
      files to access functionality of specific libraries.

1.2 Comments
------------

* The sequence of symbols // tell the compiler to ignore everything until the
  end of the current line.

* Everything between the pair of symbols /* and */ will be ignored.

1.3 A first look at variables, initialization and assignment
------------------------------------------------------------

* Variables:
    - Name of a piece of memory that is used to store information.
    - Usually defined via a declaration statement.

* Assignment:
    - Operation performed via the = symbols, which assigns r-values to l-values
      (values with an address in memory).

* Initialization:
    Variable definition + assignment.

1.3a A first look at cout, cin, endl, the std namespace and using statements
----------------------------------------------------------------------------

* std::cout
    - Object of the iostream library.
    - Used to output text to the console.
    - Used in conjunction with the output operator <<.

* std::endl
    - In contrasts to std::cout, std::endl inserts the newline character at the
      end of the stream.

* Std::cin
    - Reads input from the console.
    - Used in conjunction with the input operator <<.

* std namespace:
    - Everything within the standard library is referenced via the std
      namespace, i.e., the function cout in the standard library is referred as
      std::cout
    - There are different way to refer to the standard library:
        + Using the explicit namespace qualifier:
              std::cout << “foo”;

    - Via the "using" declaration statement:
          using std::cout;      // cout resolves to std::cout
          cout << “foo”;

    - Via the using directive statement:
          using namespace std;  // Using the standard library from here on!
          cout << “foo”;

    - If a using declaration or directive is used within a function, the names
      in the namespace are only directly accessible within that function.

1.4 First look at functions and return values
---------------------------------------------

* Function:
    - Reusable sequence of statements designed to do a particular job.
    - Can not be defined inside other functions.

* Return value:
    - The C++ standard explicitly specifies that main() should return an int.

1.4a A first look at function parameters and arguments
------------------------------------------------------

* Parameter:
    - Function variable whose value is provided by the caller.

* Argument:
    - Value passed from the caller to the function.

* Pass by value:
    - When a function is called, all its parameters are created as variables and
      the value of each parameter is copied from the matching parameter.

1.4c A first look at local scope
--------------------------------

* Scope:
    - Determines who can see and use the variable during the time of it is
      instantiated.

* Local scope:
    - Function parameters and variables declared inside the function body.
    - Local variables are created at the point of definition and destroyed when
      they go out of scope.
    - Prevents naming collisions.

1.4d Keywords and naming identifiers
------------------------------------

* Keyword:
    - Words (73 in total, up to C++11) with special meanings within the C++
      language.
    - Together with operators, define the entire C++ language.

* Identifier:
    - Name given to a variable, function, class of other object

1.7 Forward declaration and definition
--------------------------------------

* The compiler read the files sequentially.

* Forward declaration:
    - Informs the compiler about the existence of an identifier before actually
      defining the identifier.
    - Function prototype, consisting of:
        + return type, name and parameters.

* Declaration:
    - Statement that defines an identifier and its type.

* Definition:
    - Implementation or instantiation of an identifier.

1.9 Header files
----------------

* Typically only contain forward declarations.

* Header guards:
    - Prevent a given header file to be #included more than once from the same
      file.
    - As a rule of thumb, each cpp file should #include all of the header files
      it needs to compile.

* Header files with and without .h termination:
    - Use the non .h version of a library if it exist, and access the
      functionality through the std namespace. If the non .h version does not
      exist, or if you are creating your own headers, use the .h version.

* Including header files from other directories:
    - Use the -I option of the g++ compiler followed by the path to the
      containing directory.

1.10 First look at the processor
--------------------------------

* Processor:
    - Can be though as a separated program that runs just before the compiler.
    - Goes through each file looking for directives.

* Directives:
    - Specific instructions starting with # and ending with a newline. These
      directives include:
        + Includes:
            : Copy content of the included file into the including fie, at
              exactly the position where the #include directive appears.

    - Macro defines:
        + Rule defining how an input sequence is converted into a replacement
          sequence output.
        + There are two flavors: object-like (text substitution) and
          function-like (without text substitution, used for, e.g., conditional
          compilation).

    - Scope:
        + Resolved before compilation, from top to bottom and on a file-by-file
          basis, i.e.,
            : are only valid from the point of definition to the end of the file
              where they are defined.
            : Directives defined in one code file do not have impact on other
              code files in the same project.

1.10a Header guards
-------------------

* Conditional compilation directives taking the form:
      #ifndef UNIQUE_NAME
      #define UNIQUE_NAME
      // Your declarations and definitions here
      #endif

* Do not prevent a header from being included once into different code files:
    - This can result, for example, in multiple definitions of the same
      function.

* #pragma once:
    - Serves the same purpose than a header guard, with the additional benefit
      of being shorter and less error prone.
    - Not an official part of C++, therefore not supported by all compilers.

Chapter 2. Variables and Fundamental Data Types
===============================================

2.1 Fundamental variable definition, initialization and assignment
------------------------------------------------------------------

* Fundamental data types:
    - boolean:
        + bool
    - character:
        + char, wchar_t, char16_t, char32_t
    - integer:
        + short, int, long, long long
    - float:
        + float, double, long double
    - void (no type)

* Variable initialization (NOT assignment!!!):
    - copy:
         int var = 5;
    - direct:
          int var(5);
    - uniform:
          int var{5};
        : If empty, {}, set variable to default value (zero or empty depending
          on its data type).

2.4a Fixed width integers and the unsigned controversy
------------------------------------------------------

* Signed and unsigned types by size (C99, C++11):
    - 1 byte:
        + int8_t, uint8_t
    - 2 bytes:
        + int16_t, uint16_t
    - 4 bytes:
        + int32_t, uint32_t
    - 8 bytes:
        + int64_t, uint64_t

* Part of the standard library, accessible by inclusion of the header cstdint.

2.5 Floating point numbers
--------------------------

Take the form significand x 10^{exponent}

* Precision:
    - Defined by the the number of significand digits

* IEEE 754 standard, significands by byte size:
    - 4 bytes:
        + 6 - 9, typically 7
    - 8 bytes:
        + 15 - 18, typically 16
    - 16 bytes:
        + 33 - 36

2.9 Const, constexpr and symbolic constants
-------------------------------------------

* Defined with the keyword const before the variable type.
* Must be initialized while being defined, i.e., can't be changed via
  assignment.
* Can be initialized from non-constant variables.
* Commonly used with function parameters, to:
    - Show the caller that the function does not change the value of the passed
      value.
    - Ensure that the function does not modify the passed value.

* There are two type of constant variables:
    - Run time constants, defined with const.
    - Compile time constants, preferably defined with constexpr instead of
      const.

* Define constants namespace in header file instead of using MACRO-like,
  constant definitions.

Chapter 3. Operators
====================

3.3 Increment / decrement operators, and side effects
-----------------------------------------------------

* Prefix increment / decrement:
    - The value of x is incremented / decremented and, then, x is evaluated
      (returned).

* Postfix increment / decrement:
    - A temporary copy of x is created, the original variable x is incremented /
      decremented and, finally, the temporary copy is evaluated (returned).

3.4 Sizeof, comma and conditional operators
-------------------------------------------

* Comma operator (x, y):
    - Evaluate x then y and, finally, returns value of y.
    - Only recommended to be used in for loops.

* Conditional operator:
    - condition ? x : y
    - Contrary to if / else operators, which evaluate as statements, the
      conditional operator evaluates as an expression.

Chapter 4. Variable Scope and More Types
========================================

4.1 Intro
---------

* Scope:
    - Determines where a variable is accessible.

* Duration:
    - Determines where a variable is created and destroyed.

4.2 Local variables, scope and duration
---------------------------------------

* Local variables have automatic duration:
    - Are created at the point of definition and destroyed when they exit the
      block where they were created.

* Local variables have block scope (local scope):
    - They enter scope at the point of declaration and go out of scope at the
      end of the block they are defined in.

* Shadowing:
    - Nested variables in a nested block, hide / shadow variables of the outer
      block with the same name.

* Variables should be defined with the most limited scope possible.

4.2a Global variables and linkage
---------------------------------

* Global variables have static duration:
    - They are created when the program starts and destroyed when it ends.

* Global variables have global scope (“global namespace scope” or “file scope”):
    - They are visible until the end of the file where they are defined.

* Local variables shadow global variables within the block where the local
  variables are defined.

* Linkage:
    - Determines whether multiple instance of an identifier refer to the same
      variable or not.
    - Internal variable (with internal linkage):
    - Defined with the keyword static.
    - Also referred as static variables.
    - Can used anywhere within the file they are defined in, but can not be
      referenced outside the file they exist in.

* External variables (external linkage):
    - Defined with the keyword extern.
    - Can be used in both the file they are defined in, as well as in other
      files.
    - To be used in other files than the one where they are defined, a forward
      declaration with the extern keyword is needed.
    - Non-constant global variables have external linkage by default.

* Global symbolic constants:
    - To avoid replication of global constants defined via a namespace in a
      header file, do as follows;
        + Within the namespace, define these variables as global external
          variables in a separate cpp file.
        + Modify the header file to store only the forward declaration of the
          desired constant namespace.

4.3 Static duration variables
-----------------------------

* The static keyword has different meanings depending on where it is used:
    - Used with global variables:
        + Denotes internal linkage, i.e., the variable can only be used within
          the file where it is defined.

    - Used with local variables:
        + Changes them from automatic duration to static duration, i.e., retain
          their value even after the scope in which they were created has been
          exited.
        + Static local variables are created only once and are persistent until
          the end of the program.

4.3b Namespaces
---------------

* Naming collision:
    - Compiling error due to the presence of two or more identifiers with the
      same name, within the same scope.

* Namespace:
    - Area of code in which all identifiers are guaranteed to be unique.
    - By default, global variables and normal functions are defined in the
      global namespace.
    - Namespaces are intended to avoid naming collisions.
    - Namespaces creation:
          namespace Given_Name {
              // Your code goes here.
              double my_identifier();
          }

* Namespace access:
    - Scope resolution operator (::):
        + Prefix an identifier with the name of the namespace it belongs to and
          double colons, ::
              Given_Name::my_identifier();

    - using keyword:
        + Case 1. Using all identifiers in the namespace:
              using namespace Given_Name;
              my_identifier();

        + Case 2. Using specific identifiers in the namespace:
              using Given_Name::my_identifier;
              my_identifier();

    - The using keyword follows standard scope rules.

* There is no way to cancel or replace namespaces load via the using keyword.
  Their scope can only be limited by placing within a block code.

* Multiple namespace block can be declared within a single project, they can
  even be nested.

4.4a Explicit type conversion (casting)
---------------------------------------

* C-style cast:
    - Done via the () operator, with the name of the type to cast to inside:
          int my_int;
          float my_float = (float) my_int / 2;

    - Not checked by the compiler. Therefore they may get ride of consts or
      change data type without changing the underlying representation (resulting
      in garbage data).

* static_cast:
    - static_cast<new_type>(x)
    - Checked at compile time.

4.4b An introduction to std::string
-----------------------------------

* string:
    - Collection of sequential characters.

* Built-in C++ data type which is part of the standard library
  (#include <string>).

4.5 Enumerated types
--------------------

* Data type where every possible value is defined as a symbolic constant
  (enumerator).
* Declaration:
      enum Enum_Name {
          LABEL_1 = -3,
          LABEL_2,      // assigned -2.
          LABEL_3,      // assigned -1.
          LABEL_4 = 5,
          LABEL_5       // assigned 6.
      };

* Definition:
    - Enum_Name my_enum = LABEL_2;

* Enumerated values evaluate to integers.
* The compiler does not implicitly convert an integer to an enumerated value
  (static_cast can be used but is not recommended).

4.5a Enum classes
-----------------

* Also known as scoped enumeration.
* Intended to prevent the comparison of enumerators from different enumerations
  (fruits and color, for example).
* Same definition than normal enumerators, but the keyword class has to be used
  in between enum and the given name.
* The scope qualifier has to be used to access the enumerators of each
  enumeration. i.e., Enum_Name::LABEL_1.
* No implicit conversion of enumerations to integers (but static_cast can be
  used).

4.6 Typedefs and aliases
------------------------

* Allow programmers to create aliases for data types.
* Defined by the keyword typedef, followed by the type to alias, followed by the
  alias name:
    - typedef double name;
    - This does not create a new type, only defines an alias.

* Allow to easily change the underlying type of an object.
* Can be used to hide platform dependent details.

4.7 Structs
-----------

* Group variables of mixed data types together into a single unit.
* Declared with the struct keyword:
      struct Employee {
          short id = 0;     // Default initialization is a feature of C++11/14.
          int age = 0;
          double salary = 0;
      };

* Members are accessed via the member selection operator (which is a period).
* Initialization can be done via the uniform initialization scheme
  (Employee joe{32, 35, 12.6};).
* In C++11 the default and uniform initialization are incompatible, only one of
  theme can be used.
* From C++11 on, struct members can be assigned via the list initialization
  (joe = {10, 55, 123.6};).
* Structs can be passed-to and returned-from functions.
* Structs can be nested.
* Struct declaration in header files allows their use in multiple files.
    - The scope rules for structs are the same than for any other variable.

4.8 The auto keyword
--------------------

* Starting from C++11, the auto keyword may be used in place of the variable
  data type, to automatically induce the variable data type during the
  initialization.
    - Trivial feature for basic data types but useful for complex objects.

* From C++14, the auto keyword may also be used in function definitions to
  automatically infer its return type.

Chapter 6. Arrays, Strings, Pointers and References
===================================================

6.6 C-style strings
-------------------

* Array of characters that use a null terminator to indicate the string end
  (null-terminated strings).
      char my_string[] = “string”;

* The length of the string array equals the number of characters in the string
  plus one, accounting for the termination ‘\0’ character.
* Functions to manipulate C-style strings are included as part of the standard
  C++ library, just include the header <cstring>
* It is recommended to avoid the use of C-style strings.

6.7 Introduction to pointers
----------------------------

* Address of operator, &x:
    - Returns A POINTER containing the memory address of variable x.

* Dereference operator, *x:
    - Returns the value at the memory address of variable x.

* Pointer:
    - Variable that holds a memory address as its value.
    - Declared with an asterisk between the data type and the variable name,
      i.e., double *var_name;.
        + In this case the asterisk is NOT a deference, but part of the pointer
          declaration syntax!!!

* Assigning a value to a pointer:
    - Simply use the address of operator:
          int var;
          int *ptr = &var;

    - Pointer type has to match the type of the variable it points to.

* Dereferencing pointers:
    - Simply use the dereference operator, *x.

6.7a Null pointers
------------------

* Null pointer:
    - Pointer pointing to a null value (special character which means that the
      pointer is not pointing to anything).
          int *ptr1(0);
          int *ptr2;
          ptr2 = 0;

* Null pointers evaluate to 0.
* Deferencing null pointer is undefined.
* Tough 0 initialization is possible, a best practice in C++ is to initialize
  null pointers with the special keyword nullptr.

6.8 Pointers and arrays
-----------------------

* An array variable (e.g., int arr[5]) contains the address of the 1st element
  stored in the array, as if it were a pointer (&arr[0]).
* In many occasions a fixed length array will decay (i.e., be implicitly
  converted) into a pointer to the 1st array element, however:
* A fixed length array and a pointer to it, are not identical (though both point
  to the same memory address).
    - Differences:
          int arr[6];       // sizeof(arr) -> 5 * sizeof(int).
          int *ptr = arr;   // sizeof(ptr) -> size of a memory address.
          &ptr;             // yields the memory address of pointer variable.
          &arr;             // returns a pointer to the entire array.

* When passing a fixed array to a function, it decays into a pointer to its
  first element (to avoid expensive data copying) .
    - void func(int array[]) is identical to void func(int *array)

* Arrays that are part of structs or classes do not decay when the whole struct
  of class is passed to a function.

6.8a Pointer arithmetic and array indexing
------------------------------------------

* Integer addition and subtraction can be performed on pointers, i.e., ptr+1 is
  the address of the next integer / float in memory (if ptr is a pointer to int
  / float).
      int arr[5] = {5, 6, 7, 8, 9};
      *(arr + 3);   // prints 8, since arr decays into a 1st element pointer.

6.9 Dynamic memory allocation with new and delete
-------------------------------------------------

* C++ supports 3 different ways of memory allocation:
    - Static (static and global variables (stack)).
    - Automatic (function parameters and local variables (stack)).
    - Dynamic (heap):
        + Allocation (new operator):
            : Returns a pointer to the allocated memory address.
                  int *ptr = new int;

            : Throws bad_alloc exception if allocation fails.
                > Instead, a NULL pointer may be returned upon failure by using
                  nothrow:
                      int *ptr = new (std::nothrow) int;


        * Deletion (delete operator):
            : Done with the delete operator.
            : Returns memory to the operating system, but memory isn't actually
              deleted.
            : The pointer variable, however, is not affected and can be assigned
              a new value.
            : Dangling pointer:
                > Pointer to deallocated memory.

6.9a Dynamic allocating arrays
------------------------------

* Done with the array form of new and delete operators:
      int *arr = new[] int[7]();    // including direct initialization,
      delete[] arr;                 // available from C++11.

* C++  does not provide a build-in way to resize dynamically allocated arrays.
    - This functionality is via vectors in the C++ standard library.

6.10 Pointers and const
-----------------------

* Primarily used as function parameters to help ensure the function doesn't
  inadvertently changes the passes in argument.

* Pointing to a const variable:
    - That is not possible, on the contrary, it would be possible to dereference
      the non-const pointer and change the value!

* Pointer to const value:
    - Defined with the keyword const before the data type:
          const int *ptr = &var;
    - Treat var as constant when accessed through the pointer, regardless of
      whether the var was initially defined as const or not.
    - Since ptr is not constant itself, it can be redirected to point to other
      variables.
          const int *ptr = &var;
          ptr = &var2;

* Const pointers:
    - Pointers whose value can not be changed after initialization.
        + They will always point to the same address, but the value stored at
          that address does not need to be constant.

    - Defined via the *const keyword, placed between the type and the given
      name:
          int *const ptr;
    - Must be initialized upon declaration.

* Const pointer to a const value:
    - Can not be set to point to another address, nor can the value it is
      pointing to be changed through the pointer.
      const int *const ptr = &var;

6.11 Reference variables
------------------------

* New type of C++ variable (besides normal and pointer variables) that acts as
  an alias to another variables.
* Declared by using & between the reference type ans the variable name:
      int var = 5;
      int var2 = 6;
      int &ref = val;
      // Assigns the value of var2 to ref, but does not change the reference!!!
      ref = var2;

* In this case the ampersand, &, does not mean “address of”, but reference to.
* Using the address-of operator on a reference variable returns the address of
  the value being referenced.
* References are treated as being const, i.e., they must be initialized and once
  initialized they can not be changed.
* Reference to constant variables is done with the const keyword before the
  type, i.e., const int &ref = var;
    - As with the case of pointers, var does not need to be constant itself, but
      when accessed through ref, it will be treated as such.

* References are most often used as function parameters because they allow to
  pass parameters without making a copy of the value itself:
      // in this case ref is a reference to the argument passed in, not a copy.
      void func(int &ref) {.. }
      int n = 5;
      func(n);            // however, here n is a non-reference argument.

* As a rule of thumb, pass non-pointer, non-fundamental data type variables by
  (const) reference.
* Another common use of references is as shortcuts, i.e.,
  int &ref = struct1.struct2.needVar;
* When possible, references should be used instead of pointers.

6.12 Member selection with pointers and references
--------------------------------------------------

* Structure members are selected via the period operator.
* To access a struct member via a pointer, the pointer has to be dereferenced:
      struct Person {
          int age;
          double weight;

      } Person person;
      Person *ptr = &person;
      (*ptr).age; // here is where dereference occurs.

* To avoid the error prone and awkward notation, C++ incorporates the pointer
  selection operator, ->:
      ptr->age;

6.12a For-each loops
--------------------

* New range-bases loop, introduced in C++, with a simplified and secure syntax.
    - Example, use of reference avoiding copy and detecting data type:
          int arr[] = {0, 1, 1, 2, 3, ,5, 8, 13, 21};
          for(auto &ref : arr) {  // deduce the proper element type ;-).
              std::cout<<ref;
          }

* Use the use of references or const references for the element declaration in
  for-each loops.
* For-each loops work with many kinds of list-like structures (vectors, linked
  lists, trees, and maps).
* For-each loops need to know the length of the structure they are iterating:
    - Does not work with pointers to arrays :-(

6.13 Void pointers
------------------

* Generic pointers that can be pointed to objects of any data type.
* Declared as a normal pointer using the void keyword:
* Can not be dereferenced directly, but need to be casted to another pointer
  type before dereference:
      int var;
      void *ptr = &var;
      int *ptrInt = static_cast<int*>(ptr);
      std::cout<<ptrInt<<endl;

* They can be used as function parameters to pass in different data types.
* In general, void pointers should be avoided.

6.14 Pointers to pointers
-------------------------

* Pointers that hold the address of another pointers. Declared and dereferenced
  via nested asterisks:
      int var = 5
      int *ptr = &var;
      int **ptrPtr = &ptr;
      std::cout<<**ptrPtr<<endl;

* Can not be directly assigned to a value but set to null.
* Their most common use is to dynamically allocate arrays of pointers:
      // dynamic allocation of an array of 10 int pointers.
      int **arr = new int*[10];

* Allocation of two-dimensional arrays:
    1) allocate an array of pointers.
    2) iterate over it and allocate a dynamic array for each array element.
          int **arr = new int[10];
          for(int n; n < 10; n++) arr[n] = new int[5];

    - Dynamically allocated memory has to be deallocated in the opposite order
      than it was allocated.

6.15 An introduction to std::array
----------------------------------

* Provide fixed array functionality without decaying into pointers when passed
  in to functions.
* This functionality is loaded via the <array> header.
* Their size must be set a compile time:
      #include <array>
      std::array<int, 3> myArray;    // declares an integer array with length 3.

* Can be initialized using an initializer list or via uniform initialization:
      // in this case the array length can not be omitted.
      std::array<int, 5> myArray {1, 2, 3, 4, 5};

* Values can be assigned using an initializer list.
* Access to individual elements can done via :
    - The subscript operator, i.e., myArray[2] = 8;
    - The at() function. i.e., myArray.at(2) = 8;

* The library includes many useful function to deal with arrays such as size,
  sort, begin, end, etc.

6.16 An introduction to std::vector
-----------------------------------

* Provides functionality to deal with dynamic arrays in a easy and safe manner.
    - Without explicit memory allocation and deletion.

* This functionality is loaded via the <vector> header.
* No need to provide length at declaration:
      std::vector<int> arr;

* Assignment can be done via initializer-list.
* Can be initialized using an initialized list or using the uniform method.
* Elements access can be done via:
    - The subscript operator, i.e., arr[1] = 4;
    - The at() function, i.e., arr.at(1) = 4;

* When a vector variable goes out of scope, it is automatically deallocated.
* The length of a vector is provided by the size() function.
* Vector can be resized via the resize() function:
    - If increase, old elements are preserved and new entries are set to zero.
    - If reduced, element are dropped from the high-index end.
    - Resizing ix computationally expensive, better to try to avoid it.

Chapter 7. Functions
====================

7.1 Function parameters and arguments
-------------------------------------

* Parameter:
    - Variable declared in the function declaration.

* Argument:
    - Value pass to a function by the caller.

* When a function is called, all its parameters are created as variables and the
  value of the arguments are copied into the newly created parameters.

7.2 Passing arguments by value
------------------------------

* C++ default.
* Copies argument values into function parameters.
    - Arguments are never modified, only their copies may be changed (this may
      be an advantage or disadvantage).

* Mainly used to pass fundamental data types or enums.

7.3 Passing arguments by reference
----------------------------------

* In this case function parameter are declared as references rather than normal
  variables.
      void func(int &var1, float &var2, ...) {... }
    - Any changes made in the reference are passed though the whole argument.

* Returning multiple values via out parameters:
    - Function can only return a single value.
    - Multiple values can be returned via references.

* Pass by const reference:
    - Used to pass large structures (expensive to copy) but ensuring they wont
      be modified by the function, only used.

* References ALWAYS point to the same variable!

7.4 Passing arguments by address
--------------------------------

* This passes the address of the argument variable rather than the argument
  variable.
    - The function parameter must be a pointer.
    - The function can dereference the pointer to access or change the values
      being pointed.

* Typically used with arrays (with decay to pointers when passed to functions!)
  and dynamically allocated variables.
* The length must be passed as a separated argument.
* Addresses are actually passed by value:
    - When a pointer is passed to a function by address, the pointer's value
      (the address it points to) is copied from the argument to the function's
      parameter, consequently, the original pointer can be changed (point to
      somewhere else), only the copy:
          void foo(int *ptr) {
              // only the COPY of ptr is pointed to other address,
              // not the original pointer.
              ptr = nullptr;
          }
              int main() {
              int var = 5;
              int *ptr = &val;
              foo(ptr);
              std::cout<<*ptr<<endl;  // this prints 5.
          }

    - Notice that although the address is passed by value, the passed copy of
      the address can still be dereferenced to change the arguments value!!!

* Passing addresses by reference:
    - Used when we want to change the address an argument point to from within
      the function!
    - In this case the address has to be passed by reference (following a
      cumbersome syntax):
          void foo(int *&ptr) {   // ptr is now a reference to a pointer.
              ptr = nullptr;
          }
          int main() {
              int var = 5;
              int *ptr = &var;
              foo(ptr);
          }

    - C++ PASSES EVERYTHING BY VALUE.
        + However, passed addresses (copies) can be dereferenced to change the
          values of the passed in arguments.

7.4a Returning values by value, reference and address
-----------------------------------------------------

* Return by value:
    - In this case, a copy of the value is returned to the caller.
        + There are not scope issues.
        + This is a slow method to return large structures.

* Return by reference:
    - This method returns the address of a variable to the caller (copies an
      address from the function to the caller).
        + Returning the address of local variables to the caller will result in
          dangling pointers, since local variables are deallocated when the
          function ends.
        + This method is commonly used to return dynamically allocated arrays:
              int* allocatedArray(int size) {
                  return new int[size];
              }

* Return by reference:
    - A reference to the variable is passed back to the caller.
        + References to local variables should not be returned, since they go
          out of scope after function execution.
        + Typically used to return arguments passed by reference to the function
          back to the caller:
              int& foo(int &var) {
                  return(var);
              }

7.6 Function overloading
------------------------

* Feature of C++ that allows the creation of multiple functions with the same
  name, so long as they have different parameters:
      int add(int x, int y);            // integer version..
      double add(double x, double y);   // floating point version.

* During execution, the called version will depend on the passed parameters.
* Function return types are not considered for uniqueness;
      // including these two functions in the same file will result in an error.
      int foo(int x);
      double foo(int x);

* Typedefs are not distinct:
    - The following two declarations will be considered identical:
          typedef char *stringr;
          void foo(string value);
          void foo(char *value);

* Making  call to an overloaded function results in one on three possible
  scenarios:
    1) A match is found. The call is resolved to a particular overloaded
       function.
    2) No match found. The arguments can no be matched to any overloaded
       function (even after implicit type promotion).
    3) An ambiguous match is found. The arguments matched more than one
       overloaded function.

7.7 Default parameters
----------------------

* Function parameter with predefined values. If the user does not provide a
  value for this parameter, the default value will be used:
      void foo(int x, int y=7) {...}
      int main() {
          foo(5);     // this call will use the default value, i.e., foo(5, 7).
          foo(5, 3);  // in this case, the default parameter is overwritten.
      }

* Each function parameter can be assigned a default value, but:
    - Default parameters must be the rightmost parameters, i.e.,
      void foo(int x=10, int y, int z=7) is not allowed

* Default parameters can only be declared once:
    - Functions with a forward declaration MUST declare the default parameters
      on either the function declaration or the definition, but NOT both:
          void foo(int x, int y=0);
          void foo(int x, int y=0) {...}  // this will cause an error.

* The best practice is to declare the default parameters in the forward
  declaration.

* Functions with default parameters may be overloaded but the default parameters
  do NOT count as a distinctive feature. i.e., cases such as the following are
  not allowed:
      void foo(int x);
      void foo(int x, int y=10);

7.8 Function pointers
---------------------

* Similar to variable pointers but storing the address of a function.
* Declaration:
      // pointer to a function that "takes no arguments and return an integer".
      int (*funcPtr)();
    - funcPtr can point to any function that matches its signature.

* Assignment:
    - C++ implicitly converts function to function pointers if needed,
      therefore, there is no need to use the address-of operator, &.
    - Done without the () operator, i.e., :
          int foo(int x) {...}
          int goo(int y) {...}
          int main() {
              int (*funcPtr)(int) = foo;  // here funcPtr points to function foo
              funcPtr = goo;              // here it points to function goo.
          }

* Calling a function using a function pointer:
    - Explicit dereference:
          (*funcPtr)(5);  // this will call foo with the passed in argument 5.

    - Implicit derefetence:
          funcPtr(7);     // this will call foo with the passed in argument 7.
        + this looks exactly the same than a normal function!!!
            : The reason is that normal function names are nothing but pointers
              to functions ;-).

    - Default parameters are resolved at compile-time and, therefore, won't work
      for functions called via pointers.

* Passing function pointers to other functions (callback functions):
      bool inc(int x, int y) {...}        // option 1.
      bool dec(int x, int y) {...}        // option 2.
      void master(int var1, int var2, bool (*option)(int, int)) {
          if(option(var1, var2)) {...}
      }
      int main(){
          master(1, 2, inc);      // in this case master will use option 1.
          master(1, 2, dec);      // in this case master will use option 2.
      }

* Providing default functions:
      void master(int var1, int var2, bool (*option)(int, int) = inc);

* Alternative definition using std::function (<functional>) starting from C++11:
      std::function<bool(int, int)> funcPtr;

7.9 The stack and the heap
--------------------------

* Memory used by a program:
    - code segment: Stores the compiled program.
    - bss segment: Stores zero-initialized global and static variables.
    - data segment: Stores initialized global and static variables.
    - heap: Where dynamically allocated variables are allocated from.
    - call stack: Stores function parameters and local variables.

* heap:
    - Slow memory allocation.
    - Allocated memory remains allocated until deletion or program termination.
    - Allocated memory has to be accessed through pointers (~slow dereference).
    - Big pool of memory.

* stack data structure:
    - Last-in, first-out data structure, supporting three operations:
        + Look top item, top().
        + Take the top item, pop().
        + Put a new item on top, push().

* call stack:
    - Implements a stack data structure which:
        + Keeps track of all active functions from the start of the program to
          the current point of execution.
        + Handles allocation of all local variables and function parameters.

    - Has a small size (1-8Mb):
        + stack overflow is surpassed.

    - Fast memory allocation.
    - All memory allocated in the stack is known at compile-time:
        + It can be accessed through a variable.

7.10 std::vector capacity and stack behavior
--------------------------------------------

* std::vector:
    - Dynamic array (resizable).

* Length vs capacity:
    - Length:
        + How many elements are being used.

    - Capacity:
        + How many elements were allocate.

    - When a vector shrinks via resize(), it reduces its length not its capacity
      (for if it need to be increased later on).
        + Resizing (reallocation) is expensive.

    - Array subscripts and at() are based on length, not capacity.
    - Vector can be asked to reserve memory beforehand via reserve():
          std::vector<int> stack;
          stack.reserve(5); // reserves space for at least 5 integers.

* Stack implementation via vectors:
    - push_back(): pushes an element on the stack.
    - back()     : returns the value of the top element on the stack.
    - pop_back() : pops top element off the stack.
          void print(cosnt std::vector<int> &stack) {
              for(const auto &element : stack) std::cout << element<< '';
          }
          int main() {
              std::vector<int> stack;
              stack.push_back(5); print(stack); // 5     (cap 1, len 1, top 5).
              stack.push_back(3); print(stack); // 5 3   (cap 2, len 2, top 3).
              stack.push_back(1); print(stack); // 5 3 1 (cap 3, len 3, top 1).
              stack.pop_back(); print(stack);   // 5 3   (cap 3, len 2, top 3).
              stack.pop_back(); print(stack);   // 5     (cap 3, len 1, top 5).
          }

7.11 Recursion
--------------

* Function that calls itself.
* A termination condition is needed to prevent infinite calls (stack overflow).
* More expensive than iterative (loop-like) solutions, due to function overhead.
      int fibonacci(int number) {
          if(number == 0) return 0;       // base case termination condition.
          if(number == 1) return 1;       // base case termination condition.
          return fibonacci(number - 1) + fibonacci(number - 2);
      }
      int main() {
          for(int n=0; n<13; n++) std::cout << fibonacci(n) << '';
          return(0);
      }

7.12 Handling errors (assert, cerr, exit and exceptions)
--------------------------------------------------------

* Handling semantic errors (syntactically correct but unintended behavior):
    - Logic errors: Incorrect code of a logic statement.
    - violated assumption: Assumes something is either false or true but is not.

* Defensive programming:
    - Style that tries to identify areas where assumptions may be violated, and
      writes code to detect and handle any of these assumption violations.

* Detecting assumption errors:
    - At the top of each function, check to make sure any parameter have the
      appropriate values.
    - After a function has returned, check the return values, and any other
      error reporting mechanisms, to see if an error occurred.
    - Validate any user input to make sure it meets the expected formatting or
      range criteria.

* Handling assumption errors:
    - Quietly skip the code that depends on the assumption being valid.
    - Return an error code back to the caller and let the caller deal with the
      problem.
    - If, upon an assumption violation, the program needs to be terminated
      immediately, call exit() (which lives in the <cstdlib>).
    - Print an error message describing the error.

* Assert:
    - Friendly build-in function to detect violated conditions and print
      descriptive messages:
        + If the conditional expression is true, the assert statement does
          nothing, otherwise evaluates to false and prints an error message
          containig:
            : The conditional expression that failed.
            : The name of the code file where the error occurred.
            : The line number where the error occurred.

    - Loaded via <cassert>.
    - It includes some overhead each time the assert condition is checked.
    - assert can be turned off in production code via: #define NDEBUG.
          int foo(int var) {
              assert(var >= 0 && 'descriptive message!!!');
              return(0);
          }

7.13 Command line arguments
---------------------------

* Optional string arguments passed by the operating system to the program when
  it is started.
* In this case the main function takes two arguments, named argc and argv by
  convention.
    - argc:
        + Integer containing the count of the number of arguments passed to
          the program.
    - argv:
        + Argument values, stored in an array of C-like strings.
        + Numeric arguments should be converted from strings
              #include <iostream>
              #include <string>
              #include <sstream>
              int main(int argc, char *argv[]) {
                // setup a stringstream variable named convert, initialized with
                // the input from argv[1].
                std::stringstream convert(argv[1]);
                int numArg;
                if(!(convert >> numArg)) {  // DO THE CONVERSION.
                    numArg = 0;
                }
              }

Chapter 8. Basic object-oriented programming
============================================

8.2 Classes and class members
-----------------------------

* Classes:
    - Complex structures which, in addition to data, may contain functions.
    - Declared with the "class" keyword.

* Member function:
    - Function defined inside a class.

* Class members are accessed with the selection operator (.).
* By convention, class names should be start with an upper-case letter.
* Instantiation:
    - Declaration (memory allocation) of a class variable.

* Instance / Object:
    - Particular variable of a class type.
          class Class_name {
          public:
              double varDou;
              int varInt;
              void foo() {
                  std::cout << 'What a member function\n';
                  return(0);
              }
          }
          int main() {
              Class_name classVar;
              classVar.varDou = 0.2;
              classVar.foo();
          }

8.3 Public vs private specifiers
--------------------------------

* Public members:
    - Members that can be accessed from outside of the class.
    - Defined with the "public:" keyword (notice this is followed by a colon).

* Private member:
    - Members that can only be accessed by other members of the class.
    - Defined with the "private:" keyword (notice this is followed by a colon).

* Each class member acquires the access level of the previous access specifier.
* Member variables are private by default.
* Member functions are public by default.
* C++ allows structs to include member function. The fundamental difference
  between structs and classes is that, by default, all the struct members
  (variables and functions) are public.

8.4 Access functions and encapsulation
--------------------------------------

* Separating the interface from the implementation reduces the complexity of
  using objects.
* Encapsulation:
    - Access to objects is granted via a public interface, but the
      implementation is hidden to the final user.
    - Implemented via access specifiers.
    - Benefits:
        + To use fully encapsulated classes, it is only needed to know what are
          its public member functions, which arguments do they take and what
          values they return.
        + Encapsulated classes help to protect your data and prevent misuse.
        + Encapsulated classes are easier to modify and debug.

* Access functions;
    - Short public function whose job is to retrieve (Getters) or change
      (Setters) the value of a private member variable.
    - Getters should usually return by value of const reference, not non-const
      reference.

8.5 Constructors
----------------

* Public members can be initialized via an initialization list or uniform
  initialization.
* Constructors:
    - Special member function that is automatically called when an object of
      that class is instantiated.
    - Typically used to initialize member variables or setup steps necessary for
      the class to be used.
    - Special constructor rules;
        + Should always have the same name as the class (with same
          capitalization)
        + Have not return type.

    - They can not be explicitly called.

* Default constructors:
    - Constructor that takes no parameters.

* Constructor with parameters:
    - Useful to provide direct or uniform initialization of members:
          class Fraction{
          private:
              int m_var1;
              int m_var2;

          public;
              // Default constructor
              Fraction() {
                  m_var1 = 1.;
                  m_var2 = 0.;
              }

              // Constructor which takes at least one argument parameters.
              Fraction(int val1, int val2 = 3.) {
                  m_var1 = val1;
                  m_var2 = val2;
              }
          }

          int main() {
              Fraction frac1();     // Uses default constructor.
              Fraction frac2(2);    // Used the 2nd constructor with one arg.
              Fraction frac3{4,5};  // Used the 2nd constructor with two args.
          }

* Copy initialization of classes:
    - Done via the = operator, e.g., Fraction frac4 = 7;
    - Non-recommended due to performance issues.

* The number of constructors should be minimized. For the previous example, a
  default constructor can be redefined as Fraction(int val1 = 0, int val2 = 0).
* If no constructor is provided, C++ will define a default EMPTY constructor,
  which, however, does not initialize any class members.
* Classes containing classes;
    - A class may contain another classes as variables.
    - When the outer class is constructed, the member variables will have their
      default constructor called.

8.5a Constructor member initializer lists
-----------------------------------------

* Assigning values to any member variables in the body of the constructor is not
  always sufficient:
    - Some data types must be initialized in the same line they are defined.

* C++ solves the previous problem via a "member initializer list" (MIL), which:
    - Is inserted after the constructor parameters.
    - Begins with a semicolon and is followed by a comma-separated the list of
      each variable to initialize, with the desired value provided via direct
      initialization.

      class Some{
      private:
          cons int m_var1;
          int m_var2;
          int m_var3;

      public:
          Some(int val1, int val2 = 2, int val3 = 8) :
            m_var1(val1), m_var2(val2), m_var3(val3) {

          }

      }

    - In C++11 uniform initialization may be used instead of direct
      initialization, e.g., Some(int val = 1) : var{val} {}
    - Initialization lists are REQUIRED when doing composition and inheritance.
    - MIL initialize members does NOT assign values to them!

8.5b Non-static member initialization
-------------------------------------

* From C++11 on, it is possible to give non-static member variables a default
  initialization value.
      class Some{
      private;
          int var1 = 10;    // default value 10.
          int var2 = 5;     // default value 5.

      public:
          // this constructor use the default values.
          Some() {}

          // Non-default constructor using the passed in values.
          Some(int val1, val2) : var1{val1}, var2{val2} {}
      }

* If default initialization is provided, but the default constructor is missing,
  it wont be possible to create class instances.
* MIL has precedence over default initialization.
* Non-static member initialization should be favored to give default values to
  member variables.

8.6 Overlapping and delegation of constructors
----------------------------------------------

* This refers to constructors with overlapping FUNCTIONALLITY:
      class Foo{
      public:
          Foo() {
             // code to do A (replicated).
          }
          Foo(int var) {
              // code to do A (replicated).
              // code to do B (non-replicated).
          }
      }

* It is a common practice to define an Init() (defined as either public or
  private according to the actual needs) function which initializes member
  variables and is called bi the different constructors:
    class Foo{
    public:
        Foo() {
            InitA();
        }
        Foo(int var) {
            InitA();
            // code to do B.
        }
        // function doing A.
        InitA() {}
    }

* Delegating constructors:
    - Starting with C++11, constructors are allowed to call other constructors.
    - In this case the desired constructor is called in the MIL (NOT in the body
      of the calling constructor):
          class Foo{
          public:
              // constructor to do A.
              Foo() {
                  // code to do A.
              }
              // uses Foo() to do A.
              Foo(int var) : Foo() {

              }
          }

8.7 Destructors
---------------

* Special member function that is executed when an object is destroyed (clean
  ups).
* Called an object goes out of scope or when the keyword "delete" is used.
* C++ implements an automatic destructor for simple classes, but classes holding
  any resources (dynamic memory, files or databases) require and explicit
  implementation.
* Destructor naming:
    - Must have the same name than the class, preceded by a tilde (~).
    - Can not take arguments.
    - Do not have return type.

      class Foo {
      privet:
          int *m_arr;
          int m_len;

      public:
          // constructor.
          Foo(int val) : m_len{val} {
              assert(m_len > 0);
              m_arr = new int[m_len];
          }
          // destructor.
          ~Foo() {
              delete[] m_arr;
          }
      }

      int main() {
          Foo myFoo1(5);        // here the 1st instance is created.
          Foo myFoo2(5)         // here the 2nd instance is created.
          // here something is done with both array instances.
          {

          }
          // here the destructor of the 2nd instance is called.
          delete myFoo2;
      }   // here the destructor of the 1st instance is called.

* Resource Acquisition Is Initialization (RAII):
    - Programming technique whereby resource use is tied to lifetime of objects
      with automatic duration.
    - In C++, RAII is implemented via constructors and destructors.
        + A resource is acquired in the object's constructor, so that it can be
          used while the object is alive, and resources are released in the
          destructor.

* If the program calls the exit() function, destructors are not called and,
  therefore, resources are never released.

8.8 The hidden "this" pointer
-----------------------------

* All normal member functions have a "*this" pointer that refers to the object
  the function was called on. This pointer works as follows:
    - Given the implementation:
          class Foo {
          private:
              int m_var;
          public:
              Foo(int val) {
                  setVar(val);
              }
              void setVar(int val) {
                  m_var = val;
              }
              int getVar() {
                  return m_var;
              }
          };

          int main() {
              Foo myFoo(1);
              myFoo.setVar(1);
              std::cout << myFoo.getVar() <<std::endl;
              return 0;
          }
    - When myFoo.setVar(1) is called, the compiler actually calls
       setVar(&myFoo, 1).
    - Inside setVar(), the *this pointer holds the address of the object myFoo.
    - Any member variable inside setVar() are prefixed with "this->". So when we
      say m_var = val, the compiler is actually executing this->m_var = val,
      which in this case updates myFoo.m_var to val.

* *this always points to the object being operated on.
* Some times it is necessary to reference the *this pointer explicitly
  (disambiguation):
      class Foo {
      private:
          int data;                 // member variable.
      public:
          Foo(int data) {
              this->data = data;    // using this to reference the member var
          }

      };

* Chaining objects:
    - Useful to call several function on the same object.
    - Implemented by returning a pointer to the object each function is
      operating on:
          class Foo {
          privet:
              int m_var;
          public:
              Foo(int val = 1) : m_var{val} {}
              Foo& func1(int val) {// do something; return *this;}
              Foo& func2(int val) {// do something; return *this;}
              Foo& func3(int val) {// do something; return *this;}
          };
          int main() {
              Foo myFoo(1);
              myFoo.func1(2).func2(4).func3(8);     // chained functions.
          }

* The "this" pointer is implicitly added to any member function.
* It is a const pointer, i.e., its value can be changed but not the address it
  points to.

8.9 Class code and the header files
-----------------------------------

* Defining member functions outside the class definition:
    - Why is this useful?
        + Mixing the declaration and implementation makes the class harder to
          manage and work.
        + Using an already-written class only requires understanding its public
          interface.

    - In C++ it is done by defining the class member functions outside of the
      class declaration.
        + Define the class member functions as if they were normal functions,
          but prefix the class name to the function using the scope resolution
          operator (::) (same as it is done for namespaces)

          // class declaration.
          class Foo {
          private:
              int m_var1;
              int m_var2;
          public:
              Foo(int val1, int val2) : m_var1{val1}, m_var2{val2};
              void func1(int arg1, int arg2);
              Foo& func2(int arg1, int arg2);
          };
          // implementation of member functions.
          Foo::Foo(int val1, int val2) : m_var1{val1}, m_var2{val2} {
              // implementation block.
          }
          void Foo::func1(int arg1, int arg2) {
              // implementation block.
          }
          Foo& Foo::func2(int arg1, int arg2) {
              // implementation block.
              return *this;
          }

* Putting class definitions in a header file:
    - Class declarations can be put in header files so that they can be reused
      in other files or projects.
    - Class declarations are put in a header file of the same name as the class
      (traditionally).
    - Class implementations are put in a .cpp file of the same name as the
      class.
          + Header file "Foo.h":
              #ifndef FOO_H
              #define FOO_H
              class Foo {
              private:
                  int m_var1;
                  int m_var2;
              public:
                  Foo(int val1, int val2) : m_var1{val1}, m_var2{val2};
                  int func1(int arg1);
                  int fucn2();
              };
              #endif

          + Implementation file "Foo.cpp":
              # include "Foo.h"

              // Foo constructor.
              Foo::Foo(int val1, int val2) {// initialization code.}
              // Foo member functions.
              int Foo::func1(int arg1) {// func1 implementation.}
              int Foo::func2() {// func2 implementation.}

    - Any other code file that wants to use the Foo has to include "Foo.h" only
      (but, still "Foo.cpp" has to be compiled into any project that uses it).
    - If declaration and implementation are done in the same header file:
        + The class implementation will be copied and recompiled into any file
          that #includes it (slow and bulky process).

* Default parameters for member functions:
    - should be declared in the class declaration (so that they can be seen by
      any other file).

* Libraries:
    - Programs need declarations from headers for the compiler to verify that
      code being written is syntactically correct.
    - Implementation can be included in precompiled files which have to linked
      at the link stage (you never see the code).

8.10 Const class objects and member functions
---------------------------------------------

* Instantiated class objects can be made const via the "const" keyword.
* Initialization is done via class constructors.
    - After initialization, any modification of member variables is not
      possible.

* const objects can ONLY explicitly call const member functions:
* const member functions:
    - i.e., functions guarantying that they wont modify the object or call any
      non-const member functions.
    - const member functions are declared by appending the const keyword to the
      function prototype, after the parameter list, but before the function
      body.
    - Member functions with separated declaration and definition have to use the
      const keyword in both the function prototype and definition.

      class Foo {
      private:
          int m_value;
      public:
          Foo(int val = 0) : m_var{val};
          void func1(int arg1);         // non-const member function.
          void func2(int arg1) const;   // const member function.
      };

      Foo::Foo(int val = 0) : m_var{val} {};
      void func1(int arg1) {}
      void func2(int arg2) cons {       // declared as a const function.
          std::cout << arg1 << std::endl;
      }

* A common way to create constant objects is by an object to a function by
  constant reference.

8.11 Static member variables
----------------------------

* static keyword (variables):
    - Local variables:
        + The variable retains its value and is not destroyed when it goes out
          scope.

    - Global variables:
        + Restricts the use of the variable to the file where it is defined.

* Two new uses in C++:
    - static member functions.
    - static member variables.

* static member variables:
    - Shared by all objects of the class.
        + Not intrinsically associated with any class object.

    - Must be explicitly defined outside of the class, in the global scope:
        + The definition is not subject to access control, i.e., it does not
          has to include the static keyword.
        + But they also need to be declared inside the class.
        + The exception of this rule is when the static member is of type
          const int or const enum.

    - They exist even if no objects of the class have been instantiated.
        + They are created when the program starts and destroyed when it ends.
        + Can be accessed using the class name and the scope resolution
          operator, i.e., Foo::s_var = 2;

      class Foo {
      public:                              // Notice than these are public vars.
          static int var;                  // declaration of the static member.
          static const int s_exeption;     // exception to the rule.
      }
      // definition and initialization of the static member (no keyword).
      Foo:: int var = 1;

8.12 Static member functions
----------------------------

* As static variables, static functions belong to the class, not the any
  particular instance:
    - They can be called directly using the class name and the scope resolution
      operator (::), e.g., Foo::func();.

* They do not have *this pointer (they have no class object to work with!).
* They can ONLY access static member variables.
* They can be defined inside or outside of the class:
    - If defined outside, they should not be prefixed with the static keyword,
      but their declaration within the class has to.

  class Foo {
  private:
      static int m_var;            // declaration of static variable.
  public:
      static int func1(int arg1);
      static int funt2(int arg2) {
          // function body.
      }
  }
  int Foo::m_var = 1;              // definition of static variable member.
  int Foo::func1(int arg1) {       // definition of static function member.
      // do something with m_var;
  }
  int main() {
      Foo::func1();
      return 0;
  }

* C++ does not support static constructors.

8.13 Friend functions and classes
---------------------------------

* Friend function:
    - Function that can access the private members of a class as though it were
      a member of that class.

    - A friend function can be a normal function or a member function of another
      class.

    - They are declared using the "friend" keyword in front of the prototype of
      the function you wish to be a friend of the class.

        class Foo {
        private:
            int m_var;
        public:
            Foo() {m_var = 0;}
            // make myFriend() a friend of this class.
            friend void myFriend (Foo &foo);
        };

        // myFriend() is now a friend of the Foo class.
        void myFriend(Foo &foo) {
            foo.m_var = 0;  // it can directly access private members of foo.
        }

        int main() {
            Foo foo;        // create an instance of Foo.
            myFriend(foo);  // modify foo private members via a friend function.
        }

        + Notice that a Foo object had to be passed to myFriend() since, not
          being a member function, it does not have a *this pointer to work
          with.

* Multiple friends:
    - A function can be a friend of more than one class at the same time.
    - This requires the declaration of class prototypes, telling the compiler
      that classes used by myFriend() are to be defined latter on (except from
      the first class using myFriend()).

* Friend classes:
    - An entire class can be friend of another class.
    - All the members of the friend class have access to the private members of
      the other class.

        class Foo1 {
        private:
            int m_var;
        public:
            friend class Foo2;  // make the Foo2 class a friend of Foo1.
        };

        class Foo2 {
        private:
            int m_var;
        public:
            void func(Foo1 &foo1) {
                foo1.m_var = 99;
                std::cout<<foo1.m_var<<'\n';
            }
        };

        int main() {
            Foo1 foo1;
            Foo2 foo2;
            foo2.func(foo1);
        }

    - Important notes:
        + Foo2 objects have NOT direct access to the *this pointer of Foo1
          objects.
        + Foo2 -> friend -> Foo1 does NOT imply Foo1 -> friend -> Foo2.
        + A friend of B and B friend of C does not imply A friend of C.

* Friend member functions:
    - A single member function of one class can be friend of other classes.
    - In this case, the use of the member function has to be done with the
      className:: prefix included.
    - To make a member function a friend, the compiler has to see the full
      declaration of the class of the friend member function (not a mere forward
      declaration).

        class Foo2;         // forward declaration of class Foo2.

        class Foo1 {
        private:
            int foo1_var;
        public:
            // forward declaration above needed for this declaration, which, in
            // turn, will require to see the full declaration of Foo2.
            void myFriend(Foo2 &foo2);
        };

        class Foo2 {
        private:
            int foo2_var;
        public:
            // make myFriend() a friend of Foo2. This requires seeing the full
            // declaration provided above.
            friend void Foo1::myFriend(Foo2 &foo2);
        }

        // now the friend function myFriend() can be defined. This requires
        // having seen the full declaration of Foo2. This is the reason why the
        // definition had to be done out of the Foo1 class.
        void Foo1::myFriend(Foo2 &foo2) {
            foo2.foo2_var = 0;
        }

    - A better solution is to put each class declaration in a separate header
      file, with the function bodies in the corresponding .cpp files. That way,
      all the class declarations would have been visible immediately and no need
      of classes of functions rearrangements will be needed.

8.14 Anonymous variables and objects
------------------------------------

* Anonymous variable:
    - Variable that is given no name.
    - They have expression scope.
          return(5+3);  // creation of an anonymous int variable of value 8.

* Anonymous objects:
    - Objects with no name, created like normal objects but omitting the
      variable name.

* Anonymous objects are primarily used either to pass or return values without
  having to create lots of temporary variables to do so.
* Anonymous objects are treated as rvalues, i.e., they can only be passed or
  returned by value or const reference.

Chapter 9. Operator overloading
===============================

9.1 Introduction to operator overloading
----------------------------------------

* In C++ operators are implemented as functions.
    - By using function overloading on the operator functions it is possible to
      define customized operator acting on different data types.
        + This procedure is called operator overloading.

* Resolving overloaded operators:
    - If all operand are fundamental data types, the compiler calls a built-in
      routine if it exist (it produces an error if it does not exist).
    - If any of the operand are user defined data types, the compiler will look
      for an user defined matching operator:
        + If not found, it will try to convert one or more user-defined data
          type into fundamental data types, via an overloaded typecast.
        + If it fails, a compiler time error is produced.

* Limitations of operator overloading:
    - With exception of the conditional (?:), sizeof, scope (::), member
      selector (.) and member pointer selector (.*) operators, all the other
      operator can be overloaded.
    - New operators can't be created, only existing ones can be overloaded.
    - At least one of the operands in an overloaded operator must be an
      user-defined data type.
    - It is not possible to change the number of operands an operator can
      support.

* Ways of overloading an operator:
    - Via member functions.
    - Via friend functions.
    - Via normal functions.

9.2 Overloading the arithmetic operators using friend functions
---------------------------------------------------------------

* All the arithmetic operators are binary operators.
* Recipe to overload the +, -, * and / operators (example shown for +):
    - Declare a function named "operator+"
    - Declare it as taking two parameters of the classes we want to add and
      returning the appropriate data type.

          class Foo {
          private:
              int val;
          public;
              Foo(int val) : var{val} {}
              // add Foo + Foo using the "operator+" friend function.
              // although not recommended, the definition of the friend function
              // is done within the class to save space.
              friend Foo operator+(Foo &foo1, Foo &foo2) {
                  // here, the Foo constructor and the operator+(int, int) are
                  // used.
                  return Foo(foo1.var + foo2.var);
              }
          };

          int main() {
              Foo foo1(1);
              Foo foo2(2);
              Foo res = foo1 + foo2;
          }
 * Overloaded operators may operate on operands of different types, for example,
   - That process, however, is not commutative:

      Cents(4) + Cents(4);    // will call Cents operator+(Cents, Cents)
      Cents(4) + 4;           // will call Cents operator+(Cents, int)
      4 + Cents(4);           // will call Cents operator+(int, Cents)
      4 + 4;                  // will call Cents operator+(int, int)

9.2a Overloading operators using normal functions
-------------------------------------------------

* In this case these is not direct access to the private members of the class we
  are operating on. Instead, will rely on the call of a retrieving, public
  function:

    class Foo {
    private:
        int var;
    public:
        Foo(int val) : var{val} {}
        int getVal() const {return var;}   // retrieving function.
    };

    // overload operator function. Notice that this is neither a member function
    // nor a friend function.
    Foo operator+(Foo &foo1, Foo &foo2) {
        return Foo(foo1.getVal() + foo2.getVal());
    }

    int main() {
        Foo foo1(1);
        Foo foo2(2);
        Foo foo3 = foo1 + foo2;
    }
* The main difference between friend and normal operator function overloading is
  that, in the friend case, the declaration of the friend function inside the
  class, also serves a prototype. With the normal function version, an
  additional function prototype as to be provided.

* The use of normal function overloading is preferred over that of friend
  functions.

9.3 Overloading I/O operators
-----------------------------

* Usually done to print several object members at once.
* Done by overloading the << operator, whose left operand is the std::cout
  object and the right operator is the desired class instance.
* Overloading the << operator via a friend function will look like this:

    class Foo{
    private:
        int x;
        int y;
    public:
        Foo(int val1, int val2) : x{val}, y{val2} {}
        friend std::ostream& operator<<(std::ostream &out, Foo &foo);
    };
    std::ostream& operator<<(std::ostream &out, Foo &foo){
        out << "(x, y) = (" << foo.x << ", " << foo.y << ")\n";
        return out;
    }
    int main() {
        Foo foo(2,3);
        std::cout << foo;
    }

    - In this case, the left hand argument is returned as a reference.
        + This allows the overloaded operator to be chainable.

* The >> operator is overloaded in a similar way.
    - The only difference is that, in this case, we pass std::cin, which is an
      object of type std::istream.

9.4 Overloading operators using member functions
------------------------------------------------

* The recipe in this case is similar to that followed with friend functions:
* When overloading an operator using a member function:
    - The overloaded operator must be added as a member function of the left
      operand.
    - The left operand becomes the implicit *this object.
    - All the other operands become function parameters.

      class Foo {
      private:
          int m_var;
      public:
          Foo(int init) : m_var{init} {}
          // overloading the Foo + int operator.
          Foo operator+(int val);
      };
      // Notice that this is a member function (defined out of the class
      // declaration).
      // in this case, the left Foo parameter becomes the implicit *this pointer
      Foo Foo::operator+(int val) {
          return Foo(m_var + val);
      }

      int main() {
          Foo foo1(1);
          Foo foo2 = foo1 + 2;
      }

* Not every operator can be overloaded as a friend function:
    - The assignment (=), subscript ([]), function call (()) and member select
      (->) operators have to be overloaded as member functions.

* Not everything can be overloaded as a member function:
    - Examples of this are the <<, >> and operator+(int, Foo), since
      std::ostream, std::istream and int, aren't classes we can add members to.

* When to use normal, friend of member function overload?
    - Normal / friend version:
        + When dealing with binary operator that do not modify the left operand.
        + Since they work for all parameter types.
        + They are symmetric on all operands

    - Member function version:
        + When dealing with binary operators that do modify the left operand.
        + In these cases the left most operand is always a class type and the
          object being modified is pointed by the implicit *this pointer.
        + In this case there is no confusion on which operand is being modified.

    - Unary operators are usually overloaded as member functions, since the
      member version has no parameters

9.5 Overloading unary operators +, - and !
------------------------------------------

* These operators only operate in one operand.
    - They are typically implemented as member functions.

* The prototypical overloading method is as follows:

      class Foo {
      private:
          int var;
      public:
          Foo(int val) : var{val} {}
          // overload -Foo as a member function.
          Foo operator-() const;
      };
      // Definition of the overloaded member function -Foo.
      Foo Foo::operator-() const{
          return Foo(-var);
      }
      int main() {
          Foo foo1(1);
          Foo foo2 = -foo1;
      }

9.6 Overloading the comparison operators
----------------------------------------

* They follow exactly the same procedure than the binary, arithmetic operators.
* Since these are binary operators that do not modify the left operand, they
  would be preferably overloaded via friend functions.

    class Foo {
    private:
        int var;
    public:
        Foo(int val) : var{val} {}
        friend bool operator==(const Foo &foo1, const Foo &foo2);
        friend bool operator!=(const Foo &foo1, const Foo &foo2);
    };
    bool operator==(const Foo &foo1, const Foo &foo2) {
        return foo1.var && foo2.var;
    }
    bool operator!=(const Foo &foo1, const Foo &foo2) {
        return !(foo1 == foo2);
    }
    int main() {
        Foo foo1(1);
        Foo foo2(1);
        if(foo1 == foo2) return 0;
        else if(foo1 != foo2) return 1;
    }

9.7 Overloading the increment and decrement operators
-----------------------------------------------------

* These are unary operators that modify its operand
    - Therefore, they are preferably overloaded via member functions.

* Overloading the prefix version:

    class Foo {
    private:
        int var;
    public:
        Foo(int val) : var{val} {}
        Foo& operator++();
    }
    Foo& Foo::operator++() {
        ++var;
        return *this;
    }
    int main() {
        Foo foo(0);
        ++foo;
    }

    - In this case, the current implicit object is returned (*this) to allow
      multiple operations chained together.

* Overloading the postfix version:

    - C++ requires the use of a "dummy argument" to overload the postfix
      operator:
        + Otherwise the prefix and postfix operator functions would have exactly
          the same declaration.

    class Foo {
    private:
        int m_var;
    public:
        Foo(int val) : m_var{val} {}
        // here, the int argument is the dummy argument.
        Foo operator++(int);
    }
    Foo Foo::operator++(int) {
        // create a temporary variable with the current value.
        Foo temp(m_var);
        ++(*this);      // I guess this is the same than ++m_var;
        // return a copy of the state before incrementing.
        return temp;
    }
    int main() {
        Foo foo(0);
        foo++;
    }

    - Because of the additional overhead of instantiating a temporary variable,
      the postfix operator is less efficient.
    - Also notice that the postfix operator can return a reference to the
      temporary variable, since it would go out of scope when the function
      exits.

9.8 Overloading the subscript operator ([])
-------------------------------------------

* This operator have to be overloaded via member functions.
* An overloaded operator[] function will ALWAYS take one parameter:
    - The subscript that the user places between that hard braces.
        + Not necessary an integer.

* Because the result of operator[] can be used on the left hand side of an
  assignment, the return value of the operator[] must be an l-value (such as
  references).

    class Foo {
    private:
        int m_list[10];
    public:
        int& operator[] (const int index);
    };
    int& Foo::operator[] (const int index) {
        return m_list[index]
    }

* The subscript operator[] can be overloaded in two flavors, const and
  non-const:
    - The const version can be used for assignment.
    - The non-const version would rather be used for access.
    - When the const and non-const versions are defined separately, the compiler
      will select the appropriate version depending on the type of the operand:

        class Foo {
        private:
            int m_list[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        public:
            int& operator[] (int index);        // non-const version.
            const int& operator[] (int index);  // const version.
        };
        int& Foo::operator[] (int index) {
            assert(index > 0 && index < 10);    // check index out of bounds.
            return m_list[index];
        }
        const int& Foo::operator[] (int index) { return m_list[index]; }
        int main() {
            Foo fooN;       // non const instance.
            Foo fooC;       // const instance.
            fooN[2] = 3;    // calls non-const version changing value.
            fooC[2] = 3;    // this will produce a compiling time error.
            std::cout << fooC[2] << '\n' // calling const version and printing.
        }

* A good reason to overload the subscript operator[] is to prevent index out of
  bounds.
* When calling the operator[] on a pointer to an object, C++ will assume we are
  trying to index an array of objects of that type.
    - To deal with such cases, the pointer has to be dereferenced first:

      Foo *foo = new Foo;
      // error: next line will assume access to 2nd index in array of Foo's.
      foo[2] = 3;
      // next line access the 2nd element in m_list.
      (*foo)[2] = 3;        // still ugly and error prone.

* The operator[] function parameter does not has to be an integer:

      void Stupid::operator[] (std::string index) {
          std::cout << index << '\n';
      }

      int main() {
          Stupid stupid;
          stupid["this is an stupid overload"];
      }

9.9 Overloading the parenthesis operator
----------------------------------------

























